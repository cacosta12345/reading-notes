# Reading Notes Class 06

## Reading Questions

1. How can the random module be utilized in Python to generate random numbers or make selections from a list, and what are some common functions available within the module?

    * The random module in Python provides functions for generating random numbers and making selections from sequences such as lists. Some common functions available within the random module include:

    random(): Generates a random floating-point number between 0 and 1.

    randint(a, b): Generates a random integer between a and b (inclusive).

    choice(seq): Returns a random element from the non-empty sequence seq.

    shuffle(seq): Randomly shuffles the elements of the sequence seq in place.

    sample(population, k): Returns a random sample of k elements from the population sequence without replacement.

2. In the context of software development, what is risk analysis, and what are the key steps involved in conducting a risk analysis for a software project?

    * Risk analysis in software development involves identifying, assessing, and prioritizing potential project risks. Steps include identifying risks, assessing their impact and likelihood, mitigating them with preventive measures, planning for contingencies, and ongoing monitoring and communication.

3. What is test coverage and why is it an important (or potentially misleading) metric in software testing?

    * Test coverage refers to the extent to which a software application's source code is tested by its associated test suite. It measures the percentage of code lines, branches, or paths executed during testing compared to the total number of lines, branches, or paths in the codebase.

4. What is Big O notation, and how is it used to describe the performance of an algorithm? Give an example of an everyday task (not software related) that demonstrates O(n) time complexity.

    * Big O notation is a mathematical notation used to describe the efficiency or complexity of an algorithm in terms of its input size. It provides an upper bound on the growth rate of an algorithm's time or space requirements as the input size increases.